# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Чекменев В.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|  20.12       |     4         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в языке пролог можно сравнить со связным списком из императивных языков. Структура связного списка такова, что элемент состоит из данных и указателя на следующий элемент. Также, в императивных языках существуют двунаправленный список, отличие которого от однонаправленного лишь в том, что в элементе хранится указатель и на предыдущий элемент. Это дает возможность итерироваться вперед и назад по списку. Однако, что касается пролога, то в нем представлен односвязный список.

## Задание 1.1: Предикат обработки списка
 
`insert_mine(Item, K, List, Result)` - Добавляет элемент Item на позицию K в список List. Результатом вставки, если она является успешной, является список Result.

Примеры использования:
```prolog
?- insert_mine(4, 3, [1, 1, 1, 1], L).
L = [1, 1, 4, 1, 1] .
?- insert_mine(5, 2, [1, 2, 3], L). 
L = [1, 5, 2, 3] .
?- insert_mine(X, 3, [1, 1, 1], [1, 1, 6, 1]).  
X = 6;
```

Реализация с помощью стандратного предиката `append`:
```prolog
append([], List2, List2).
append([Head|Tail], List2, [Head|Result]):-
   append(Tail, List2, Result).


addtolist(Item, 1, [Head|Tail], Result) :-
	append([Item], [Head], New),
	append(New, Tail, Result).
	
addtolist(Item, K, [Head|Tail], Result) :-
	K > 1,
	K1 is K - 1, 
    addtolist(Item, K1, Tail, List),
    append([Head], List, Result).
```

С помощью рекурсии доходим до нужной позиции и с помощью стандартного предиката `append` вставляем элемент в список на эту позицию.

Реализация с помощью своего предиката:
```prolog
insert_mine(Item, 1, [Head|Tail], Result) :-
	Tail \= [],
	Result = [Item, Head|Tail].
	
insert_mine(Item, 1, [], Result) :-
	Result = [Item].

insert_mine(Item, K, [Head|Tail], Result) :-
	K > 1,
	K1 is K - 1,
	insert_mine(Item, K1, Tail, List),
	Result = [Head|List].
```

Предикат идет с помощью рекурсии по списку, вычитая каждый раз из позиции, в которую надо вставить единицу. Если нужная позиция будет равна 1, то вставляем наш элемент перед "головой" и "хвостом". Затем рекурсивно добавляем в результирующий список "головы" предыдущих элементов.

## Задание 1.2: Предикат обработки числового списка

`mycheck(L)` - Проверяет список на арифметическую прогрессию

Примеры использования:
```prolog
?- mycheck([1, 3, 5]).
true ;
?- mycheck([4, 5, 4, 3, 7]). 
false.
24 ?- mycheck([8]).        
true ;
```

Реализация с помощью стандратного предиката `sublist`:
```prolog
makePr([X], X, _, _).
makePr([Head|Tail], Head, K, N) :-
	N > 1,
	G is N - 1,
	X is Head + K,
	makePr(Tail, X, K, G).

sublist([], _).
sublist([X|Tail1],[X|Tail2] ) :- sublist(Tail1, Tail2).

check(L) :- L = [_].
check(L) :- L = [_, _].
check([Head1, Head2|Tail]) :-
	X is Head2 - Head1,
	length([Head1, Head2|Tail], K),
	makePr(PrList, Head1, X, K), 
    length(PrList, K),
    sublist([Head1, Head2|Tail], PrList).
```

Сначала создается список, с арифметической прогрессией, равной разности первых двух элементов, а затем полученный список с правильной арифметической прогрессией сравнивается с введенным списком.

Реализация с помощью своего предиката:
```prolog
checkPr_mine([H1, H2|Tail], M) :-
	N is H2 - H1,
	M = N,
	Tail \= [],
	checkPr_mine([H2|Tail], M). 
checkPr_mine([H1, H2|Tail], M) :-
	N is H2 - H1,
	M = N,
	Tail = [].

check_mine(L) :-
	L = [_].
check_mine(L) :-
	L = [_, _].
check_mine([H1, H2|Tail]) :-
	M is H2 - H1,
	checkPr_mine([H2|Tail], M).
```

Предикат вычисляет разность первых двух элементов, затем вызывает предикат checkPr_mine, передавая все элементы, кроме первого и разность первых двух элементов. checkPr_mine проверяет, равна ли разность двух элементов с разностью первых двух, если нет, то возвращает fail, если да и есть в списке больше 2 элементов, то рекурсивно вызывает себя, передавая "хвост" для текущей "головы".


## Задание 2: Реляционное представление данных

Главным преимуществом реляционного представления является ее простота: таблица интуитивно понятна человеку, так как наглядно описывает все поля каждой записи.
Недостатком реляционного представления можно назвать медленный доступ к данным, так как при худшей реализацией для того, чтобы получить нужное значение, необходимо проверить значения всех идущих до него элементов. Также этот метод не эффективен по памяти.

Примеры использования:
```prolog
?- print_members([102]).
102
[Петров,Ивановский,Шарпин,Эксель,Криптовалютников,Азурин,Круглотличников]
?- dont_pass().
Количество несдавших в группе 101: 2
Количество несдавших в группе 102: 4
Количество несдавших в группе 103: 3
Количество несдавших в группе 104: 4
?- print_average_mark([101,102]). 
Среднее значение для 101 группы: 3.9
Среднее значение для 102 группы: 3.7777777777777777
```

Реализация:
```prolog
:- encoding(utf8).
:- consult('one.pl').

%
% Task: Get a table of groups and the average score for each of the groups
%

print_groups_members() :-
	group_list(GrList),
	print_members(GrList).
print_groups_members() :-
	group_list(GrList),
	print_average_mark(GrList).

%
% List of groups
%

group(N) :-
	student(N, _).

group_list(L) :-
	setof(Gr, group(Gr), L).

%
% Students in the group
%

print_members([Gr|T]) :-
	write(Gr), nl, 
    setof(Stud, student(Gr, Stud), L), 
    write(L), nl, nl, 
    print_members(T), fail.

%
% Average score for the group
%

print_average_mark([Gr|T]) :-
	aver_mark(Gr, Res),
	write("Среднее значение для "), 
	write(Gr), write(" группы: "),
	write(Res), nl, 
    print_average_mark(T), fail.

aver_mark(Gr, Res) :-
	findall(Mark, (student(Gr, Stud), grade(Stud, _, Mark)), L), 
    length(L, Len),
    sum_list(L, S),
    Res is (S / Len).

%
% Task: For each subject, get a list of students who failed the exam (grade=2)
%

print_bad_marks() :-
	subject(N, M),
	write(M), nl, 
    bagof(Y, grade(Y, N, 2), L), 
    write(L), nl, nl, fail.

%
% Task: Find the number of failed students in each of the groups
%

dont_pass() :-
	group_list(Gr),
	print_dont_pass(Gr).

has_bad_mark(Stud, Gr) :-
	student(Gr, Stud),
	grade(Stud, _, 2).

print_dont_pass([H|T]) :-
	setof(Stud, has_bad_mark(Stud, H), L),
	length(L, Len),
    write("Количество несдавших в группе "),
    write(H), write(": "), write(Len), nl, 
    print_dont_pass(T), fail.
```
Описание предикатов:
`print_bad_marks()` - для каждого предмета печатает список студентов, несдавших экзамен. Для каждого найденного предмета с помощью предиката bagof находится список несдавших этот экзамен, а затем выводится на экран.

`print_groups_members()` - печатает таблицу студентов каждой группы, а затем средний балл по группе. Он реализован с помощью трех предикатов:
  + `group_list(GroupL)` - с помощью предиката setof ищет весь список групп, и определяет GrL.
  + `print_members(GroupL)` - для каждой группы из списка групп с помощью предиката setof создает список студентов из группы и выводит список в консоль.
  + `print_average_mark(GroupL)` - для каждой группы из списка групп создает список оценок, считает сумму всех элементов списка и его длину, считает среднее значение всех оценок и выводит значение в консоль.

`dont_pass()` - для каждой группы выводит число студентов, несдавших экзамены. Он реализова с помощью двух предикатов:
+ `group_list(GroupL)` - с помощью предиката setof ищет весь список групп, и определяет GrL.
+ `print_dont_pass([Head|Tail])` - для каждой группы с помощью предиката setof ищет список студентов, получивших 2, затем считает длину списка и выводит в консоль.

## Выводы

Программирование на языке пролог, как и на других неимперативных языках немного другого рода. Привычный, императивный, подход отличается наглядностью для человека, который просто читает код, потому что код написан инструкция за инструкцией. Однако код на логическом языке пропитан методами, которые зачастую не используются в императивных языках и смысл пролог прорамм не лежит на поверхности, и лишь по этой причине программирование на прологе чудно и сложно в первые разы. Однако я уверен, что это только начало и в будущем я не только научусь лучше программировать на прологе, но и повышу уровень написания кода на более привычных языках.

