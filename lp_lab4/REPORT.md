# Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Чекменев В.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
  Обработка текстов на естественном языке (Natural Language Processing, NLP) — общее направление искусственного интеллекта и математической лингвистики. Оно изучает проблемы компьютерного анализа и синтеза текстов на естественных языках. Применительно к искусственному интеллекту анализ означает понимание языка, а синтез — генерацию грамотного текста. 
  В обработке естественных и искусственных языков в прологе часто используется грамматика, построенная на определённых предложениях (DCG). Однако эта технология - всего лишь синтаксический сахар и нам ничего не мешать воспользоваться обычным синтаксисом пролога.
  В целом, пролог часто оказывается одним из самых удобных средств для таких задач, так как нам не нужно описывать структуры, порождаемые грамматическим разбором. В прологе нам необходимо лишь описать всевозможные атомы предложения и комбинировать их.

## Задание

Вариант 9:
Реализовать разбор фраз языка (вопросов), выделяя в них неизвестный объекты.

## Принцип решения

### опишем базу знаний

+ имена людей -- `agents` 

``` prolog
agent(['Даша', 'Маша', 'Саша', 'Паша']).
```

+ обекты `objects` 

``` prolog
object(['шоколад', 'деньги', 'кровать', 'стена', 'книга', 'алгоритм']).
```

+ глаголы в трех формах `verbs`

``` prolog
verb(Verbs) :- Verbs = 
    ['любить' : ['любит', 'любят'],
     'лежать' : ['лежат', 'лежит'],
     'программировать' : ['программирует', 'программируют'],
     'стать' : ['спал', 'стали'],
     'сдать' : ['сдал', 'сдали']].
```

### опишем три разных типа вопросов

+ обработка вопроса, в котором неизвестна локация объекта

``` prolog
% пример : Где лежит книга?
% неизвестна локация
ask(['Где', Verb, Noun, E], X) :- 
    question_mark(E),
    search_verb(Verb, Inf),
    object(List),
    member(Noun, List),
    X=..[Inf, object(Noun), loc(x)].
```

+ обработка вопроса, в котором неизвестен агент

``` prolog
% пример : Кто программирует алгоритм?
ask(['Кто', Verb, Noun, E], X) :- 
    end_mark(E),
    find(Verb, Inf),
    X=..[Inf, agent(y), object(Noun)].
```

+ обработка вопроса, в котором неизвестен объект

``` prolog
% пример : Что любит Даша?
ask(['Что', Verb, Noun, E], X) :- 
    end_mark(E),
    find(Verb, Inf),
    agent(List),
    member(Noun, List),
    X=..[Inf, agent(Noun), object(y)].
```


## Результаты

1. первый тип вопроса: Где лежит книга?

```prolog
?- ask(['Где', лежит, книга, ?], X).
X = лежать(object(книга), loc(x)).
```

2. второй тип вопроса: Кто программирует алгоритм?

```prolog
?- ask(['Кто', программирует, алгоритм, ?], X).
X = программировать(agent(y), object(алгоритм)).
```

3. третий тип вопроса: Что любит Даша?

```prolog
?- ask(['Что', любит, 'Даша', ?], X).
X = любить(agent('Даша'), object(y)).
```

## Выводы

Я попытался использовать DC грамматику для написания программы, однако по ней очень мало информации в интернете и лекциях. Исходя из этого, я выбрал использовать стандартный синтаксис пролога. Это никак не изменило семантику программы, она стала лишь немного длинее и невыразительнее. К тому же, я узнал о таком интересном предикате как op, который какбы дает возможность определить свой оператор, что является опять же очень удобным сиинтаксическим сахаром.

Данная лабораторная работа была очень интересна с практической стороны, так как в реальных проектах часто встречается обработка естественного или искусственного языков. Хоть в них лично и не присутствует пролог, однако сама идея грамматического разбора на прологе дала полезные знания, которые можно будет потом применить, программируя на _реальных_ язфках программирования. Например грамматический разбор применяется в поиске (например, яндекс или гул поиск), чат-ботах и тд.

Пролог оказался действительно удобным именно со стороны бэкэнда проекта, так как с обычным SWI прологом не сделать приятный пользовательский интерфейс, который часто требуется в реальных проектах. Но мы все же и не собираемся писать на прологе поиск и подобные вещи, так как он будет работать очень медленно, что будет неприятно для конечного пользователя.


Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.




